<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CoinUtils: Coin::ReferencedObject Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CoinUtils
   &#160;<span id="projectnumber">2.11.4</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceCoin.html">Coin</a></li><li class="navelem"><a class="el" href="classCoin_1_1ReferencedObject.html">ReferencedObject</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classCoin_1_1ReferencedObject-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Coin::ReferencedObject Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classCoin_1_1ReferencedObject.html" title="ReferencedObject class. ">ReferencedObject</a> class.  
 <a href="classCoin_1_1ReferencedObject.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="CoinSmartPtr_8hpp_source.html">CoinSmartPtr.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a33f8fa7df67d7f03d1e381fc0f3cdf29"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCoin_1_1ReferencedObject.html#a33f8fa7df67d7f03d1e381fc0f3cdf29">ReferencedObject</a> ()</td></tr>
<tr class="separator:a33f8fa7df67d7f03d1e381fc0f3cdf29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e4ce3e01905b3cf1d14978edaed8a6e"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCoin_1_1ReferencedObject.html#a5e4ce3e01905b3cf1d14978edaed8a6e">~ReferencedObject</a> ()</td></tr>
<tr class="separator:a5e4ce3e01905b3cf1d14978edaed8a6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaff7edf8827ff4c4dfda7e715ec5149"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCoin_1_1ReferencedObject.html#abaff7edf8827ff4c4dfda7e715ec5149">ReferenceCount</a> () const</td></tr>
<tr class="separator:abaff7edf8827ff4c4dfda7e715ec5149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cc5067735851d52937883558dc03baf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCoin_1_1ReferencedObject.html#a0cc5067735851d52937883558dc03baf">AddRef</a> () const</td></tr>
<tr class="separator:a0cc5067735851d52937883558dc03baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a228dfb18d4f7533bd0fb8f58772af4cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCoin_1_1ReferencedObject.html#a228dfb18d4f7533bd0fb8f58772af4cb">ReleaseRef</a> () const</td></tr>
<tr class="separator:a228dfb18d4f7533bd0fb8f58772af4cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classCoin_1_1ReferencedObject.html" title="ReferencedObject class. ">ReferencedObject</a> class. </p>
<p>This is part of the implementation of an intrusive smart pointer design. This class stores the reference count of all the smart pointers that currently reference it. See the documentation for the <a class="el" href="classCoin_1_1SmartPtr.html" title="Template class for Smart Pointers. ">SmartPtr</a> class for more details.</p>
<p>A <a class="el" href="classCoin_1_1SmartPtr.html" title="Template class for Smart Pointers. ">SmartPtr</a> behaves much like a raw pointer, but manages the lifetime of an object, deleting the object automatically. This class implements a reference-counting, intrusive smart pointer design, where all objects pointed to must inherit off of <a class="el" href="classCoin_1_1ReferencedObject.html" title="ReferencedObject class. ">ReferencedObject</a>, which stores the reference count. Although this is intrusive (native types and externally authored classes require wrappers to be referenced by smart pointers), it is a safer design. A more detailed discussion of these issues follows after the usage information.</p>
<p>Usage Example: Note: to use the <a class="el" href="classCoin_1_1SmartPtr.html" title="Template class for Smart Pointers. ">SmartPtr</a>, all objects to which you point MUST inherit off of <a class="el" href="classCoin_1_1ReferencedObject.html" title="ReferencedObject class. ">ReferencedObject</a>.</p>
<pre class="fragment"> * 
 * In MyClass.hpp...
 * 
 * #include "CoinSmartPtr.hpp"

 * 
 * class MyClass : public Coin::ReferencedObject // must derive from ReferencedObject
 *    {
 *      ...
 *    }
 * 
 * In my_usage.cpp...
 * 
 * #include "CoinSmartPtr.hpp"
 * #include "MyClass.hpp"
 * 
 * void func(AnyObject&amp; obj)
 *  {
 *    Coin::SmartPtr&lt;MyClass&gt; ptr_to_myclass = new MyClass(...);
 *    // ptr_to_myclass now points to a new MyClass,
 *    // and the reference count is 1
 *    
 *    ...
 * 
 *    obj.SetMyClass(ptr_to_myclass);
 *    // Here, let's assume that AnyObject uses a
 *    // SmartPtr&lt;MyClass&gt; internally here.
 *    // Now, both ptr_to_myclass and the internal
 *    // SmartPtr in obj point to the same MyClass object
 *    // and its reference count is 2.
 * 
 *    ...
 * 
 *    // No need to delete ptr_to_myclass, this
 *    // will be done automatically when the
 *    // reference count drops to zero.
 * 
 *  }   
 *  
 * </pre><p>Other Notes: The <a class="el" href="classCoin_1_1SmartPtr.html" title="Template class for Smart Pointers. ">SmartPtr</a> implements both dereference operators -&gt; &amp; *. The <a class="el" href="classCoin_1_1SmartPtr.html" title="Template class for Smart Pointers. ">SmartPtr</a> does NOT implement a conversion operator to the raw pointer. Use the GetRawPtr() method when this is necessary. Make sure that the raw pointer is NOT deleted. The <a class="el" href="classCoin_1_1SmartPtr.html" title="Template class for Smart Pointers. ">SmartPtr</a> implements the comparison operators == &amp; != for a variety of types. Use these instead of </p><pre class="fragment"> *    if (GetRawPtr(smrt_ptr) == ptr) // Don't use this
 *    </pre><p> <a class="el" href="classCoin_1_1SmartPtr.html" title="Template class for Smart Pointers. ">SmartPtr</a>'s, as currently implemented, do NOT handle circular references. For example: consider a higher level object using SmartPtrs to point to A and B, but A and B also point to each other (i.e. A has a <a class="el" href="classCoin_1_1SmartPtr.html" title="Template class for Smart Pointers. ">SmartPtr</a> to B and B has a <a class="el" href="classCoin_1_1SmartPtr.html" title="Template class for Smart Pointers. ">SmartPtr</a> to A). In this scenario, when the higher level object is finished with A and B, their reference counts will never drop to zero (since they reference each other) and they will not be deleted. This can be detected by memory leak tools like valgrind. If the circular reference is necessary, the problem can be overcome by a number of techniques:</p>
<p>1) A and B can have a method that "releases" each other, that is they set their internal SmartPtrs to NULL. </p><pre class="fragment"> *        void AClass::ReleaseCircularReferences()
 *          {
 *          smart_ptr_to_B = NULL;
 *          }
 *        </pre><p> Then, the higher level class can call these methods before it is done using A &amp; B.</p>
<p>2) Raw pointers can be used in A and B to reference each other. Here, an implicit assumption is made that the lifetime is controlled by the higher level object and that A and B will both exist in a controlled manner. Although this seems dangerous, in many situations, this type of referencing is very controlled and this is reasonably safe.</p>
<p>3) This <a class="el" href="classCoin_1_1SmartPtr.html" title="Template class for Smart Pointers. ">SmartPtr</a> class could be redesigned with the Weak/Strong design concept. Here, the <a class="el" href="classCoin_1_1SmartPtr.html" title="Template class for Smart Pointers. ">SmartPtr</a> is identified as being Strong (controls lifetime of the object) or Weak (merely referencing the object). The Strong <a class="el" href="classCoin_1_1SmartPtr.html" title="Template class for Smart Pointers. ">SmartPtr</a> increments (and decrements) the reference count in <a class="el" href="classCoin_1_1ReferencedObject.html" title="ReferencedObject class. ">ReferencedObject</a> but the Weak <a class="el" href="classCoin_1_1SmartPtr.html" title="Template class for Smart Pointers. ">SmartPtr</a> does not. In the example above, the higher level object would have Strong SmartPtrs to A and B, but A and B would have Weak SmartPtrs to each other. Then, when the higher level object was done with A and B, they would be deleted. The Weak SmartPtrs in A and B would not decrement the reference count and would, of course, not delete the object. This idea is very similar to item (2), where it is implied that the sequence of events is controlled such that A and B will not call anything using their pointers following the higher level delete (i.e. in their destructors!). This is somehow safer, however, because code can be written (however expensive) to perform run-time detection of this situation. For example, the <a class="el" href="classCoin_1_1ReferencedObject.html" title="ReferencedObject class. ">ReferencedObject</a> could store pointers to all Weak SmartPtrs that are referencing it and, in its destructor, tell these pointers that it is dying. They could then set themselves to NULL, or set an internal flag to detect usage past this point.</p>
<p>Comments on Non-Intrusive Design: In a non-intrusive design, the reference count is stored somewhere other than the object being referenced. This means, unless the reference counting pointer is the first referencer, it must get a pointer to the referenced object from another smart pointer (so it has access to the reference count location). In this non-intrusive design, if we are pointing to an object with a smart pointer (or a number of smart pointers), and we then give another smart pointer the address through a RAW pointer, we will have two independent, AND INCORRECT, reference counts. To avoid this pitfall, we use an intrusive reference counting technique where the reference count is stored in the object being referenced. </p>

<p class="definition">Definition at line <a class="el" href="CoinSmartPtr_8hpp_source.html#l00157">157</a> of file <a class="el" href="CoinSmartPtr_8hpp_source.html">CoinSmartPtr.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a33f8fa7df67d7f03d1e381fc0f3cdf29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33f8fa7df67d7f03d1e381fc0f3cdf29">&#9670;&nbsp;</a></span>ReferencedObject()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Coin::ReferencedObject::ReferencedObject </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="CoinSmartPtr_8hpp_source.html#l00159">159</a> of file <a class="el" href="CoinSmartPtr_8hpp_source.html">CoinSmartPtr.hpp</a>.</p>

</div>
</div>
<a id="a5e4ce3e01905b3cf1d14978edaed8a6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e4ce3e01905b3cf1d14978edaed8a6e">&#9670;&nbsp;</a></span>~ReferencedObject()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Coin::ReferencedObject::~ReferencedObject </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="CoinSmartPtr_8hpp_source.html#l00163">163</a> of file <a class="el" href="CoinSmartPtr_8hpp_source.html">CoinSmartPtr.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="abaff7edf8827ff4c4dfda7e715ec5149"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaff7edf8827ff4c4dfda7e715ec5149">&#9670;&nbsp;</a></span>ReferenceCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Coin::ReferencedObject::ReferenceCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="CoinSmartPtr_8hpp_source.html#l00164">164</a> of file <a class="el" href="CoinSmartPtr_8hpp_source.html">CoinSmartPtr.hpp</a>.</p>

</div>
</div>
<a id="a0cc5067735851d52937883558dc03baf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cc5067735851d52937883558dc03baf">&#9670;&nbsp;</a></span>AddRef()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Coin::ReferencedObject::AddRef </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="CoinSmartPtr_8hpp_source.html#l00165">165</a> of file <a class="el" href="CoinSmartPtr_8hpp_source.html">CoinSmartPtr.hpp</a>.</p>

</div>
</div>
<a id="a228dfb18d4f7533bd0fb8f58772af4cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a228dfb18d4f7533bd0fb8f58772af4cb">&#9670;&nbsp;</a></span>ReleaseRef()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Coin::ReferencedObject::ReleaseRef </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="CoinSmartPtr_8hpp_source.html#l00166">166</a> of file <a class="el" href="CoinSmartPtr_8hpp_source.html">CoinSmartPtr.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/<a class="el" href="CoinSmartPtr_8hpp_source.html">CoinSmartPtr.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
